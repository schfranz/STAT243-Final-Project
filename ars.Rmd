---
title: "STAT243_final_project"
author: "Jennifer Wiederspahn"
date: "12/10/2018"
output: word_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Adaptive Rejection Sampling

STAT243 Fall 2018 Final Project
Group members: Franziska Schmidt, Weijie Yuan, Jennifer Wiederspahn
Github: schfranz

### Introduction 

Here, we describe a method for adaptive rejection sampling from any univariate log-concave probability density function. The method works without determination of the mode by making use of an envelope and a squeezing function which converge to the density $f(x)$ as sampling proceeds. The assumption of log-concavity of $f(x)$ avoids locating the supremum of $g(x)$. Furthermore, the probability of needing to evaluate $g(x)$ is further reduced by using the recently acquired information about g(x). Thus, the number of evaluations of $g(x)$ is reduced. For derivative based Adaptive Rejection Sampling, we assume that $g(x)$ is continuous and differentiable everywhere in domain D. $h(x) = ln g(x)$, s.t. $h(x)$ is concave everywhere in D. 
Generally speaking, the algorithm can be divided up into the following steps: To initialize the sampling,  a set of fixed points is evaluated and the log-density $h$, as well as its derivative are evaluated on the fixed points. Next, these function evaluations are used to construct a piecewise-linear, upper bound h+ for the log-density function via supporting tangent lines of the log-density at the fixed points. Assuming that $g^{+} = exp(h^{+})$, sampling $Y ~ g^{+}$ is straightforward because $g6{+}$ is piecewise-exponential. More specifically, after having picked $U ~ Unif(0,1)$, $Y$ is accepted if $U \leq exp(h(Y) - h^{+}(Y))$. Otherwise, another sample is drawn from $g^{+}$ and the rejected $Y$ can be added to the initial set of fixed points and the piecewise-linear upper bound $h^{+}$ allowing for an adaptive update. 


### Approach 


*1. Main function*
- main adaptive rejection sampling function
- log of the original function
- find starting x_k
- initialize output variable
- iterate until we have enough points
- calculate h_k and derivative of h_k
- intersection points
- cumulative envelop: Calculate areas under exponential upper bound function for normalization purposes, Normalize, Sampling: Generate seeds for Inverse CDF method, Rejection testing, update accpeted points to sample, update x_k

*2. Supporting functions* 


- generate intersect z_j


- initialization: results are not bound, you just extend from -inf to +inf -> include to inf?
- create upper hull in a vectorized fashion, take exponential
- create lower hull in a vectorized fashion
- sample from the envelope
- Sample from uniform random
- Rescale sample value w to area of the selected segment, since area under segment is not equal to 1
- Use inverse CDF of selected segment to generate a sample
- rejection test: Generate random seed, squeeze and reject tests indicator for adding point in boolean form, get rejection point for squeeze and accept test
- Return boolean indicator whether to accept candidate sample point






 

*3. Testing*

1. check whether f is positive in range from var_lower to var_upper
- f is continuous
- choose a test point in interval
- check if the sign of boundary values differ
- calculate derivative of a function instead of "grad"
- if limit doesn't exist then we need to stop
- check h(x) is concave
- test for log-concavity
- something to mention: the random number generator iterates over results after 626 unique values which can pose a problem if the user tries to generate a large sample size. We have noticed this but have not implemented a solution since

### Contributions

*Weijie Yuan:*
*Franziska Schmidt:*
*Jennifer Wiederspahn:* R package and report writing

